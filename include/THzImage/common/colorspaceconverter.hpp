#ifndef THZ_IMAGE_COMMON_COLORSPACECONVERTER_HPP
#define THZ_IMAGE_COMMON_COLORSPACECONVERTER_HPP

#include "THzCommon/math/constants.hpp"

#include <algorithm>
#include <cstdint>

namespace Terrahertz {

/// @brief Converts a BGR to a HSV color.
///
/// @param blue The blue value of the BGR color.
/// @param green The green value of the BGR color.
/// @param red The red value of the BGR color.
/// @param hue Output: The hue of the HSV color [rad].
/// @param saturation Output: The saturation of the HSV color.
/// @param value Output: The value of the HSV color.
inline void BGRtoHSV(std::uint8_t const blue,
                     std::uint8_t const green,
                     std::uint8_t const red,
                     float             &hue,
                     std::uint8_t      &saturation,
                     std::uint8_t      &value) noexcept
{
    auto const max = std::max(std::max(blue, green), red);
    auto const min = std::min(std::min(blue, green), red);
    // Hue
    if (min == max)
    {
        hue = 0.0;
    }
    else if (red == max)
    {
        hue = PiF / 3.0f * ((green - blue) / static_cast<float>(max - min));
    }
    else if (green == max)
    {
        hue = PiF / 3.0f * (2 + ((blue - red) / static_cast<float>(max - min)));
    }
    else // if (blue == max)
    {
        hue = PiF / 3.0f * (4 + ((red - green) / static_cast<float>(max - min)));
    }
    if (hue < 0.0f)
    {
        hue += 2.0f * PiF;
    }

    // Saturation
    saturation = ((max == 0) ? 0 : static_cast<std::uint8_t>(((max - min) / static_cast<float>(max)) * 255.0f));

    // Value
    value = max;
}

/// @brief Converts a HSV to a BGR color.
///
/// @param hue The hue of the HSV color [rad].
/// @param saturation The saturation of the HSV color.
/// @param value The value of the HSV color.
/// @param blue Output: The blue value of the BGR color.
/// @param green Output: The green value of the BGR color.
/// @param red Output: The red value of the BGR color.
inline void HSVtoBGR(float const        hue,
                     std::uint8_t const saturation,
                     std::uint8_t const value,
                     std::uint8_t      &blue,
                     std::uint8_t      &green,
                     std::uint8_t      &red) noexcept
{
    if (value == 0 || saturation == 0)
    {
        blue = green = red = value;
    }
    else
    {
        // accounting for rounding errors
        auto const s  = saturation / 255.01f;
        auto       hi = static_cast<std::uint8_t>(hue / (PiF / 3.0f));
        auto       f  = hue / (PiF / 3.0f) - hi;
        auto       p  = value * (1.0f - s);
        auto       q  = value * (1.0f - s * f);
        auto       t  = value * (1.0f - s * (1.0f - f));
        switch (hi)
        {
        case 0:
        case 6:
            red   = static_cast<std::uint8_t>(value);
            green = static_cast<std::uint8_t>(t);
            blue  = static_cast<std::uint8_t>(p);
            break;
        case 1:
            red   = static_cast<std::uint8_t>(q);
            green = static_cast<std::uint8_t>(value);
            blue  = static_cast<std::uint8_t>(p);
            break;
        case 2:
            red   = static_cast<std::uint8_t>(p);
            green = static_cast<std::uint8_t>(value);
            blue  = static_cast<std::uint8_t>(t);
            break;
        case 3:
            red   = static_cast<std::uint8_t>(p);
            green = static_cast<std::uint8_t>(q);
            blue  = static_cast<std::uint8_t>(value);
            break;
        case 4:
            red   = static_cast<std::uint8_t>(t);
            green = static_cast<std::uint8_t>(p);
            blue  = static_cast<std::uint8_t>(value);
            break;
        case 5:
            red   = static_cast<std::uint8_t>(value);
            green = static_cast<std::uint8_t>(p);
            blue  = static_cast<std::uint8_t>(q);
            break;
        }
    }
}

/// @brief Converts a mini HSV color value to a BGR color.
///
/// @param minihsv The mini HSV color value.
/// @param blue Output: The blue value of the BGR color.
/// @param green Output: The green value of the BGR color.
/// @param red Output: The red value of the BGR color.
inline void
MiniHSVtoBGR(std::uint8_t const minihsv, std::uint8_t &blue, std::uint8_t &green, std::uint8_t &red) noexcept
{
    static uint8_t MiniHSVBlueLookup[256U] = {
        0x0DU, 0x29U, 0x45U, 0x61U, 0x7DU, 0x99U, 0xB5U, 0xD1U, 0x09U, 0x1DU, 0x31U, 0x45U, 0x59U, 0x6DU, 0x81U, 0x95U,
        0x05U, 0x11U, 0x1DU, 0x29U, 0x35U, 0x41U, 0x4DU, 0x59U, 0x01U, 0x05U, 0x09U, 0x0DU, 0x11U, 0x15U, 0x19U, 0x1DU,
        0x0DU, 0x29U, 0x45U, 0x61U, 0x7DU, 0x99U, 0xB5U, 0xD1U, 0x09U, 0x1DU, 0x31U, 0x45U, 0x59U, 0x6DU, 0x81U, 0x95U,
        0x05U, 0x11U, 0x1DU, 0x29U, 0x35U, 0x41U, 0x4DU, 0x59U, 0x01U, 0x05U, 0x9U,  0x0DU, 0x11U, 0x15U, 0x19U, 0x1DU,
        0x0DU, 0x29U, 0x45U, 0x61U, 0x7DU, 0x99U, 0xB5U, 0xD1U, 0x09U, 0x1DU, 0x31U, 0x45U, 0x59U, 0x6DU, 0x81U, 0x95U,
        0x05U, 0x11U, 0x1DU, 0x29U, 0x35U, 0x41U, 0x4DU, 0x59U, 0x01U, 0x05U, 0x09U, 0x0DU, 0x11U, 0x15U, 0x19U, 0x1DU,
        0x0FU, 0x2DU, 0x4CU, 0x6AU, 0x89U, 0xA7U, 0xC6U, 0xE4U, 0x0DU, 0x29U, 0x44U, 0x60U, 0x7BU, 0x97U, 0xB2U, 0xCEU,
        0x0CU, 0x24U, 0x3DU, 0x55U, 0x6EU, 0x86U, 0x9FU, 0xB7U, 0x0AU, 0x20U, 0x35U, 0x4BU, 0x60U, 0x76U, 0x8BU, 0xA0U,
        0x10U, 0x30U, 0x50U, 0x70U, 0x90U, 0xB0U, 0xD0U, 0xF0U, 0x10U, 0x30U, 0x50U, 0x70U, 0x90U, 0xB0U, 0xD0U, 0xF0U,
        0x10U, 0x30U, 0x50U, 0x70U, 0x90U, 0xB0U, 0xD0U, 0xF0U, 0x10U, 0x30U, 0x50U, 0x70U, 0x90U, 0xB0U, 0xD0U, 0xF0U,
        0x10U, 0x30U, 0x50U, 0x70U, 0x90U, 0xB0U, 0xD0U, 0xF0U, 0x10U, 0x30U, 0x50U, 0x70U, 0x90U, 0xB0U, 0xD0U, 0xF0U,
        0x10U, 0x30U, 0x50U, 0x70U, 0x90U, 0xB0U, 0xD0U, 0xF0U, 0x10U, 0x30U, 0x50U, 0x70U, 0x90U, 0xB0U, 0xD0U, 0xF0U,
        0x10U, 0x30U, 0x50U, 0x70U, 0x90U, 0xB0U, 0xD0U, 0xF0U, 0x10U, 0x30U, 0x50U, 0x70U, 0x90U, 0xB0U, 0xD0U, 0xF0U,
        0x10U, 0x30U, 0x50U, 0x70U, 0x90U, 0xB0U, 0xD0U, 0xF0U, 0x10U, 0x30U, 0x50U, 0x70U, 0x90U, 0xB0U, 0xD0U, 0xF0U,
        0x0EU, 0x2CU, 0x49U, 0x67U, 0x84U, 0xA2U, 0xBFU, 0xDDU, 0x0CU, 0x24U, 0x3DU, 0x55U, 0x6EU, 0x86U, 0x9FU, 0xB7U,
        0x09U, 0x1DU, 0x30U, 0x44U, 0x57U, 0x6AU, 0x7EU, 0x91U, 0x07U, 0x15U, 0x24U, 0x32U, 0x40U, 0x4FU, 0x5DU, 0x6CU};

    static uint8_t MiniHSVGreenLookup[256U] = {
        0x0EU, 0x2CU, 0x49U, 0x67U, 0x84U, 0xA2U, 0xBFU, 0xDDU, 0x0CU, 0x24U, 0x3DU, 0x55U, 0x6EU, 0x86U, 0x9FU, 0xB7U,
        0x09U, 0x1DU, 0x30U, 0x44U, 0x57U, 0x6AU, 0x7EU, 0x91U, 0x07U, 0x15U, 0x24U, 0x32U, 0x40U, 0x4FU, 0x5DU, 0x6CU,
        0x10U, 0x30U, 0x50U, 0x70U, 0x90U, 0xB0U, 0xD0U, 0xF0U, 0x10U, 0x30U, 0x50U, 0x70U, 0x90U, 0xB0U, 0xD0U, 0xF0U,
        0x10U, 0x30U, 0x50U, 0x70U, 0x90U, 0xB0U, 0xD0U, 0xF0U, 0x10U, 0x30U, 0x50U, 0x70U, 0x90U, 0xB0U, 0xD0U, 0xF0U,
        0x10U, 0x30U, 0x50U, 0x70U, 0x90U, 0xB0U, 0xD0U, 0xF0U, 0x10U, 0x30U, 0x50U, 0x70U, 0x90U, 0xB0U, 0xD0U, 0xF0U,
        0x10U, 0x30U, 0x50U, 0x70U, 0x90U, 0xB0U, 0xD0U, 0xF0U, 0x10U, 0x30U, 0x50U, 0x70U, 0x90U, 0xB0U, 0xD0U, 0xF0U,
        0x10U, 0x30U, 0x50U, 0x70U, 0x90U, 0xB0U, 0xD0U, 0xF0U, 0x10U, 0x30U, 0x50U, 0x70U, 0x90U, 0xB0U, 0xD0U, 0xF0U,
        0x10U, 0x30U, 0x50U, 0x70U, 0x90U, 0xB0U, 0xD0U, 0xF0U, 0x10U, 0x30U, 0x50U, 0x70U, 0x90U, 0xB0U, 0xD0U, 0xF0U,
        0x0FU, 0x2DU, 0x4CU, 0x6AU, 0x89U, 0xA7U, 0xC6U, 0xE4U, 0x0DU, 0x29U, 0x44U, 0x60U, 0x7BU, 0x97U, 0xB2U, 0xCEU,
        0x0CU, 0x24U, 0x3DU, 0x55U, 0x6EU, 0x86U, 0x9FU, 0xB7U, 0x0AU, 0x20U, 0x35U, 0x4BU, 0x60U, 0x76U, 0x8BU, 0xA0U,
        0x0DU, 0x29U, 0x45U, 0x61U, 0x7DU, 0x99U, 0xB5U, 0xD1U, 0x09U, 0x1DU, 0x31U, 0x45U, 0x59U, 0x6DU, 0x81U, 0x95U,
        0x05U, 0x11U, 0x1DU, 0x29U, 0x35U, 0x41U, 0x4DU, 0x59U, 0x01U, 0x05U, 0x09U, 0xDU,  0x11U, 0x15U, 0x19U, 0x1DU,
        0x0DU, 0x29U, 0x45U, 0x61U, 0x7DU, 0x99U, 0xB5U, 0xD1U, 0x09U, 0x1DU, 0x31U, 0x45U, 0x59U, 0x6DU, 0x81U, 0x95U,
        0x05U, 0x11U, 0x1DU, 0x29U, 0x35U, 0x41U, 0x4DU, 0x59U, 0x01U, 0x05U, 0x09U, 0xDU,  0x11U, 0x15U, 0x19U, 0x1DU,
        0x0DU, 0x29U, 0x45U, 0x61U, 0x7DU, 0x99U, 0xB5U, 0xD1U, 0x09U, 0x1DU, 0x31U, 0x45U, 0x59U, 0x6DU, 0x81U, 0x95U,
        0x05U, 0x11U, 0x1DU, 0x29U, 0x35U, 0x41U, 0x4DU, 0x59U, 0x01U, 0x05U, 0x09U, 0xDU,  0x11U, 0x15U, 0x19U, 0x1DU};

    static uint8_t MiniHSVRedLookup[256U] = {
        0x10U, 0x30U, 0x50U, 0x70U, 0x90U, 0xB0U, 0xD0U, 0xF0U, 0x10U, 0x30U, 0x50U, 0x70U, 0x90U, 0xB0U, 0xD0U, 0xF0U,
        0x10U, 0x30U, 0x50U, 0x70U, 0x90U, 0xB0U, 0xD0U, 0xF0U, 0x10U, 0x30U, 0x50U, 0x70U, 0x90U, 0xB0U, 0xD0U, 0xF0U,
        0x0FU, 0x2FU, 0x4EU, 0x6EU, 0x8DU, 0xADU, 0xCCU, 0xECU, 0x0FU, 0x2DU, 0x4CU, 0x6AU, 0x89U, 0xA7U, 0xC6U, 0xE4U,
        0x0EU, 0x2CU, 0x49U, 0x67U, 0x84U, 0xA2U, 0xBFU, 0xDDU, 0x0EU, 0x2AU, 0x47U, 0x63U, 0x80U, 0x9CU, 0xB9U, 0xD5U,
        0x0EU, 0x2AU, 0x47U, 0x63U, 0x80U, 0x9CU, 0xB9U, 0xD5U, 0x0AU, 0x20U, 0x35U, 0x4BU, 0x60U, 0x76U, 0x8BU, 0xA0U,
        0x07U, 0x15U, 0x24U, 0x32U, 0x40U, 0x4FU, 0x5DU, 0x6CU, 0x03U, 0x0BU, 0x12U, 0x19U, 0x21U, 0x28U, 0x30U, 0x37U,
        0x0DU, 0x29U, 0x45U, 0x61U, 0x7DU, 0x99U, 0xB5U, 0xD1U, 0x09U, 0x1DU, 0x31U, 0x45U, 0x59U, 0x6DU, 0x81U, 0x95U,
        0x05U, 0x11U, 0x1DU, 0x29U, 0x35U, 0x41U, 0x4DU, 0x59U, 0x01U, 0x05U, 0x09U, 0x0DU, 0x11U, 0x15U, 0x19U, 0x1DU,
        0x0DU, 0x29U, 0x45U, 0x61U, 0x7DU, 0x99U, 0xB5U, 0xD1U, 0x09U, 0x1DU, 0x31U, 0x45U, 0x59U, 0x6DU, 0x81U, 0x95U,
        0x05U, 0x11U, 0x1DU, 0x29U, 0x35U, 0x41U, 0x4DU, 0x59U, 0x01U, 0x05U, 0x09U, 0x0DU, 0x11U, 0x15U, 0x19U, 0x1DU,
        0x0EU, 0x2AU, 0x47U, 0x63U, 0x80U, 0x9CU, 0xB9U, 0xD5U, 0x0AU, 0x20U, 0x35U, 0x4BU, 0x60U, 0x76U, 0x8BU, 0xA0U,
        0x07U, 0x15U, 0x24U, 0x32U, 0x40U, 0x4FU, 0x5DU, 0x6CU, 0x03U, 0x0BU, 0x12U, 0x19U, 0x21U, 0x28U, 0x30U, 0x37U,
        0x0FU, 0x2FU, 0x4EU, 0x6EU, 0x8DU, 0xADU, 0xCCU, 0xECU, 0x0FU, 0x2DU, 0x4CU, 0x6AU, 0x89U, 0xA7U, 0xC6U, 0xE4U,
        0x0EU, 0x2CU, 0x49U, 0x67U, 0x84U, 0xA2U, 0xBFU, 0xDDU, 0x0EU, 0x2AU, 0x47U, 0x63U, 0x80U, 0x9CU, 0xB9U, 0xD5U,
        0x10U, 0x30U, 0x50U, 0x70U, 0x90U, 0xB0U, 0xD0U, 0xF0U, 0x10U, 0x30U, 0x50U, 0x70U, 0x90U, 0xB0U, 0xD0U, 0xF0U,
        0x10U, 0x30U, 0x50U, 0x70U, 0x90U, 0xB0U, 0xD0U, 0xF0U, 0x10U, 0x30U, 0x50U, 0x70U, 0x90U, 0xB0U, 0xD0U, 0xF0U};

    blue  = MiniHSVBlueLookup[minihsv];
    green = MiniHSVGreenLookup[minihsv];
    red   = MiniHSVRedLookup[minihsv];
}

/// @brief Converts a BGR color to a gray-value.
///
/// @param blue The blue value of the BGR color.
/// @param green The green value of the BGR color.
/// @param red The red value of the BGR color.
/// @return The gray value for the color.
/// @remarks The conversion is perceptual luminance-preserving.
inline std::uint8_t BGRtoGray(std::uint8_t const blue, std::uint8_t const green, std::uint8_t const red) noexcept
{
    return static_cast<std::uint8_t>((0.0722F * blue) + (0.7152F * green) + (0.2126F * red));
}

} // namespace Terrahertz

#endif // !THZ_IMAGE_COMMON_COLORSPACECONVERTER_HPP
